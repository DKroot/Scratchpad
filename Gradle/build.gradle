/*
## Main tasks ##

  main                        demo different Gradle features

## Informational tasks ##

  vars (v)                    shows environment variables and JVM System Properties

  properties (prop)           shows project properties

  dependencies (depe)         shows dependency trees for all configurations
    Options:
      --configuration {dependency-configuration-name}

  buildEnvironment (bE)       shows dependency tree for plugins

  tiTree {task}               shows the task dependencies as a tree

  tiOrder {task1} ...         shows order of all would be executed tasks

## Common options ##

  --info                      show detailed progress. Recommended for `docker`.

  --scan                      create a Gradle build scan diagnostics, published to the Gradle-hosted website
*/

plugins {
  id 'base'
  id 'java'

  id 'de.qualersoft.jmeter' version '2.4.+'

  // Prints task metadata and dependency information
  id 'org.barfuin.gradle.taskinfo' version '2.2.+'
}

println "Built by Gradle ${gradle.gradleVersion} (${gradle.gradleHomeDir})"
def systemEnv = System.getenv()
// a Java Map of env. vars
def sysPath = systemEnv.getOrDefault("PATH", systemEnv.Path)
println "Using PATH=${sysPath}"

// Ad-hoc (extra) project properties must be *created* via `[project.]ext.`
project.ext.foo = 'foo extra initial value'
println "foo=${foo}"

/*
ERROR: `Could not set unknown property 'bar'`
project.bar = 'bar extra initial value'
println "bar=${bar}"
*/

// After that though they can be read and re-written directly on `[project.]`
foo = 'foo'
println "foo=${foo}"

def bar = 'bar local var'
println "bar=${bar}"

if (foo) {
  def baz = 'baz local var value'
  ext.baz = 'baz extra'
  // Local var shadows (takes precedence over) the project property
  println "baz=${baz}"
  println "project.baz=${project.baz}"
}
println "baz ouside of the local block=${baz}"

if (project.ext.has('qux')) {
  println "Property qux=${project.ext.qux}"
} else {
  println "Property qux is not defined."
}

def qux = project.ext.has('qux') ? project.ext.qux : 'default'
println "qux=${qux}"

/**
 * Converts 'false', 'FALSE', 'False', null, '' to false, everything else to true.
 */
static boolean isTruthy(String s) {
  return s && s.toLowerCase() != 'false'
}

def boolProp = project.ext.has('boolProp') && isTruthy(project.ext.boolProp as String)
if (boolProp) {
  println "Property boolProp is truthy."
} else {
  println "Property boolProp is falsy."
}

final def JAVA_VER = 17

java {
  /*
  Set up all compile, test and javadoc tasks to use the defined toolchain which may be different than the one Gradle
  itself uses. Gradle detects locally installed JVMs and chooses a JRE/JDK matching the requirements. If no match is
  found, it will automatically download it from a specified vendor.
  */
  toolchain {
    languageVersion = JavaLanguageVersion.of(JAVA_VER)
    vendor = JvmVendorSpec.AMAZON // optional, defaults to `AdoptOpenJDK`
  }

  consistentResolution {
    useCompileClasspathVersions()
  }
}

// Print command line of all `Exec` tasks (but not direct `exec {}` calls
allprojects {
  tasks.withType(Exec).tap {
    configureEach {
      doFirst {
        println "${workingDir}> `${commandLine.join ' '}`"
      }
    }
  }
}

import javax.inject.Inject

interface ExecOps {
  @Inject
  ExecOperations getExecOps()
}

interface FsOps {
  @Inject
  FileSystemOperations getFsOps()
}

tasks.register('myExec', Exec) {
  doFirst { // Prologue
    println "\nmyExec: Executing a command"
    println '====='
  }

  //workingDir '../tomcat/bin'
  commandLine 'ls'

  doLast { // Epilogue
    println '====='
  }
}

import org.apache.tools.ant.util.TeeOutputStream

/**
 * Executes command, tees and captures stdout
 *
 * @param cmdLineArgs
 * @param suppressFailures ignore failed commands
 * @return captured stdout
 */
String runAndCaptureStdOut(cmdLineArgs, suppressFailures = false) {
  def execOps = project.objects.newInstance(ExecOps).execOps
  println "${projectDir}> `${cmdLineArgs.join ' '}`"
  new ByteArrayOutputStream().withStream { cmdStdOut ->
    execOps.exec {
      commandLine cmdLineArgs
      standardOutput new TeeOutputStream(System.out, cmdStdOut)
      ignoreExitValue suppressFailures
    }
    cmdStdOut.toString()
  }
}

/**
 * Executes command, tees and captures stdout and stderr. Ignores failed commands.
 *
 * @param cmdLineArgs
 * @return a tuple of captured stdout + captured stderr
 */
Tuple2<String, String> runAndCaptureStdOutStdErr(cmdLineArgs) {
  def execOps = project.objects.newInstance(ExecOps).execOps
  println "${projectDir}> `${cmdLineArgs.join ' '}`"
  new ByteArrayOutputStream().withStream { cmdStdOut ->
    new ByteArrayOutputStream().withStream { cmdStdErr ->
      execOps.exec {
        commandLine cmdLineArgs
        standardOutput new TeeOutputStream(System.out, cmdStdOut)
        errorOutput new TeeOutputStream(System.err, cmdStdErr)
        ignoreExitValue true
      }
      new Tuple2<>(cmdStdOut.toString(), cmdStdErr.toString())
    }
  }
}

tasks.register('execCommands') {
  dependsOn myExec
  def execOps = project.objects.newInstance(ExecOps).execOps
  doLast {
    println "\nexecCommands: Executing a command and suppressing a failure"
    println '====='
    def result = execOps.exec {
      commandLine 'ls', 'foo'
      ignoreExitValue true
    }
    println "Completed with the exit code: ${result.exitValue}"
    println '====='

    println "\nExecuting a command and capturing stdout and stderr"
    println '====='
    new ByteArrayOutputStream().withStream { cmdStdOut ->
      new ByteArrayOutputStream().withStream { cmdStdErr ->
        execOps.exec {
          commandLine 'ls', '-l'
          standardOutput cmdStdOut
          errorOutput cmdStdErr
        }
        println '===== stdout:'
        print cmdStdOut
        println '===== stderr:'
        print cmdStdErr
        println '====='
      }
    }

    def cmdLineArgs = ['ls', '-l']
    println "\nExecuting a command and teeing stdout and stderr"
    println '====='
    println "<main>: ${projectDir}> `${cmdLineArgs.join ' '}`"
    new ByteArrayOutputStream().withStream { cmdStdOut ->
      new ByteArrayOutputStream().withStream { cmdStdErr ->
        execOps.exec {
          commandLine cmdLineArgs
          standardOutput new TeeOutputStream(System.out, cmdStdOut)
          errorOutput new TeeOutputStream(System.err, cmdStdErr)
        }
        println '===== Captured stdout:'
        print cmdStdOut
        println '===== Captured stderr:'
        print cmdStdErr
        println '====='
      }
    }

    println "\nExecuting a command with error suppression and teeing stdout and stderr via generic function"
    println '====='
    def cmdOutput = runAndCaptureStdOutStdErr(['ls', 'foo'])
    println '===== Captured stdout:'
    print cmdOutput.first
    println '===== Captured stderr:'
    print cmdOutput.second
    println '====='

    println "\nExecuting a command andÏ€ teeing stdout via generic function"
    println '====='
    def cmdStdOut = runAndCaptureStdOut(['ls', '-l'])
    println '===== Captured stdout:'
    print cmdStdOut
    println '====='
  }
}

tasks.register('generateConfig') {
  def configFileSource = 'config/example.service'
  def generatedConfigDir = "${buildDir}/generated"

  doLast {
    def requiredVars = ['custom_prop']
    for (def requiredVar in requiredVars) {
      assert systemEnv.containsKey(requiredVar): "`$requiredVar` is not set in the environment"
      project.ext[requiredVar] = systemEnv[requiredVar]
    }

    println("\n== Project Properties ==\n")
    for (def var in project.properties.sort()) {
      println "${var.key}=${var.value}"
    }

    // Can't do filtering copy directly into the target: it requires sudo
    copy {
      from "${configFileSource}"
      into "${generatedConfigDir}"
      expand(project.properties)
      // TODO report. Blows up for an unclear reason.
      //            expand(systemEnv)
      filteringCharset = 'UTF-8'
      //            eachFile { println "${it.file} => ${generatedConfigDir}/" }
    }
  }
}

/*tasks.register('setFilePermissions') {
  def fsOps = project.objects.newInstance(FsOps).fsOps
  doLast {
    //def fsOps = project.getExtensions().getByType(FileSystemOperations)
    def file = file('gradlew.bat')
    fsOps.filePermissions {
      files = file('gradlew.bat')
      user {
        read = true
        execute = true
      }
      other.execute = false
    }
  }
}*/

println "ext.foo=${ext.foo}"
println "ext.baz=${ext.baz}"

/**
 * Custom function
 */
void fun() {
  println "fun()>"
  println "foo=${foo}"
  /*
  ERROR: Could not get unknown property 'bar'

  println "bar=${bar}"
  */
  println "baz=${baz}"
}

tasks.register('printVars') {
  group 'Help'
  description 'Prints environment, JVM System Properties and other project info.'

  println 'task :printVars in configuration phase.'
  println "foo=${foo}"
  println "bar=${bar}"
  println "baz=${baz}"

  /*
  Fail: extra properties extension does not exist.

  println "ext.foo=${ext.foo}"
  println "ext.bar=${ext.bar}"
  */

  doLast {
    println "foo=${foo}"
    println "bar=${bar}"
    println "baz=${baz}"

    /*
    Fail: extra properties extension does not exist.

    println "ext.foo=${ext.foo}"
    println "ext.baz=${ext.baz}"
    */

    println "project.ext.foo=${project.ext.foo}"
    println "project.ext.baz=${project.ext.baz}"

    fun()

    println '== Environment variables ==\n'
    systemEnv.sort().each { key, value -> println "${key}=${value}"
    }

    println '\n== JVM System Properties ==\n'
    System.properties.sort().each { key, value -> println "${key}=${value}"
    }

    println '\n== Project Properties ==\n'
    project.properties.sort().each { key, value ->
      switch (key) {
        case 'ext':
          println '=== Extra Project Properties ==='
          project.ext.properties.sort().each { k, v ->
            println "${k}=${v}"
          }
          println '=== </Extra Project Properties> ==='
          break
        case 'properties':
          break
        default:
          println "${key}=${value}"
      }
    }
  }
}

defaultTasks = ['execCommands', 'generateConfig', 'printVars']