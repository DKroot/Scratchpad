/*
## Main tasks ##
* main                        demo different Gradle features

## Informational tasks ##
*  vars (v)                    shows environment variables and JVM System Properties
*  properties (prop)           shows project properties
*  dependencies (depe)         shows dependency trees for all configurations
    Options:
      --configuration {dependency-configuration-name}
*  buildEnvironment (bE)       shows dependency tree for plugins

## Common options ##
* --info                      show detailed progress. Recommended for `docker`.
* --scan                      create a Gradle build scan diagnostics, published to the Gradle-hosted website
* --dry-run                   run the builds with all task actions disabled
* --task-graph                print task graph instead of executing tasks
*/

buildscript {
  repositories {
    mavenCentral()
  }

  // Make the `javax.inject API` available for the build script itself.
  dependencies {
    classpath 'javax.inject:javax.inject:1'
  }
}

plugins {
  id 'base'
  id 'java'

  //region Client-side stack
  // (automatically downloaded) `Node.js` and `npm` support
  id 'com.github.node-gradle.node' version '7.1.+'
  //endregion
}


import org.apache.tools.ant.util.TeeOutputStream

import javax.inject.Inject

interface ExecOps {
  @Inject
  ExecOperations getExecOps()
}

/*
interface FsOps {
  @Inject
  FileSystemOperations getFsOps()
}
*/

//region Startup Info
def systemEnv = System.getenv()

// Potential `os` values: `Linux`, `Mac OS X`, `Windows 11`, `Windows Server 2019`
def os = System.getProperty('os.name')
project.ext.isLinux = (os.contains('Linux'))
project.ext.isWindows = (os.contains('Windows'))

if (logger.isEnabled(LogLevel.LIFECYCLE)) {
  print "Built by Gradle ${gradle.gradleVersion} on "
  if (project.ext.isLinux) {
    print 'Linux'
  } else if (project.ext.isWindows) {
    print 'Windows'
  } else {
    print os
  }
  println " @ ${gradle.gradleHomeDir}"
  if (logger.isEnabled(LogLevel.DEBUG)) {
    def execOps = project.objects.newInstance(ExecOps).execOps
    println 'By the OS user:'
    if (project.ext.isWindows) {
      execOps.exec {
        commandLine 'whoami', '/user'
      }
    } else {
      execOps.exec {
        commandLine 'id'
      }
    }
  }

  // `System.properties['java.vendor.version']` may point to a JVM different from Gradle's
  logger.lifecycle "Gradle is running on: ${System.properties['java.vendor']} ${System.properties['java.vm.version']}" +
      " @ ${System.properties['java.home']}"
}
//endregion

// The output directory for project's binary artifacts. It doesn't have to exist initially.
def binDir = layout.buildDirectory.dir('libs')

// Ad-hoc (extra) project properties must be *created* via `[project.]ext.`
project.ext.foo = 'foo extra initial value'
println "foo=${foo}"

/*
ERROR: `Could not set unknown property 'bar'`
project.bar = 'bar extra initial value'
println "bar=${bar}"
*/

// After that though they can be read and re-written directly on `[project.]`
foo = 'foo'
println "foo=${foo}"

def bar = 'bar local var'
println "bar=${bar}"

if (foo) {
  def baz = 'baz local var value'
  ext.baz = 'baz extra'
  // Local var shadows (takes precedence over) the project property
  println "baz=${baz}"
  println "project.baz=${project.baz}"
}
println "baz ouside of the local block=${baz}"

if (project.ext.has('qux')) {
  println "Property qux=${project.ext.qux}"
} else {
  println "Property qux is not defined."
}

def qux = project.ext.has('qux') ? project.ext.qux : 'default'
println "qux=${qux}"

/**
 * Converts 'false', 'FALSE', 'False', null, '' to false, everything else to true.
 */
static boolean isTruthy(String s) {
  return s && s.toLowerCase() != 'false'
}

/**
 * Checks that the extra property is not absent/null, 'false' (case-insensitive), or ''.
 */
boolean isTruthyProp(String prop) {
  project.ext.has(prop) && isTruthy(project.ext[prop] as String)
}

def boolProp = isTruthyProp('boolProp')
if (boolProp) {
  println "Property boolProp is truthy."
} else {
  println "Property boolProp is falsy."
}

final def JAVA_VER = 21

java {
  /*
  Set up all compile, test and javadoc tasks to use the defined Java toolchain which may be different than the one
  Gradle itself uses. Locally installed JVMs are detected and JRE/JDK matching the requirements below is chosen. If no
  match is found, Gradle will automatically download and use the right JDK from a specified vendor.
  */
  toolchain {
    languageVersion = JavaLanguageVersion.of(JAVA_VER)
    //vendor = JvmVendorSpec.AMAZON // optional, defaults to `AdoptOpenJDK`
  }

  consistentResolution {
    useCompileClasspathVersions()
  }
}

// Print command line of all `Exec` tasks (but not direct `exec {}` calls
allprojects {
  tasks.withType(Exec).tap {
    configureEach {
      doFirst {
        println "${workingDir}> `${commandLine.join ' '}`"
      }
    }
  }
}

/**
 * Detects and returns the path to the Node.js executable depending on the current OS.
 * The method assumes that Node.js is already set up through the `nodeSetup` task.
 *
 * @return RegularFile pointing to the node executable (`node.exe` on Windows, `node` on Unix-like systems)
 */
RegularFile detectNodeExecutable() {
  //dependsOn nodeSetup
  node.resolvedNodeDir.file(project.ext.isWindows ? 'node.exe' : 'bin/node').get()
}

/**
 * Executes an OS command
 *
 * @param cmdLineArgs An array of the command line args, e.g., {@code ['/bin/echo', 'hello world']}
 * @param suppressFailures Whether to ignore (continue after) failed commands, defaults to false
 * @param extraEnvVars A map of additional environment variables to pass: {@code ['VAR1': 'value1', 'VAR2': 'value2']}
 */
ExecResult run(cmdLineArgs, suppressFailures = false, Map<String, ?> extraEnvVars = [:]) {
  def execOps = project.objects.newInstance(ExecOps).execOps
  logger.lifecycle "${projectDir}> `${cmdLineArgs.join ' '}`"
  execOps.exec {
    commandLine = cmdLineArgs
    environment(extraEnvVars)
    ignoreExitValue = suppressFailures
  }
}

tasks.register('myExec', Exec) {
  doFirst { // Prologue
    println "\nmyExec: Executing a command"
    println '====='
  }

  //workingDir '../tomcat/bin'
  commandLine 'ls'

  doLast { // Epilogue
    println '====='
  }
}
/**
 * Executes command, tees and captures stdout
 *
 * @param cmdLineArgs
 * @param suppressFailures ignore failed commands
 * @return captured stdout
 */
String runAndCaptureStdOut(cmdLineArgs, suppressFailures = false) {
  def execOps = project.objects.newInstance(ExecOps).execOps
  println "${projectDir}> `${cmdLineArgs.join ' '}`"
  new ByteArrayOutputStream().withStream { cmdStdOut ->
    execOps.exec {
      commandLine = cmdLineArgs
      standardOutput = new TeeOutputStream(System.out, cmdStdOut)
      ignoreExitValue = suppressFailures
    }
    cmdStdOut.toString()
  }
}

/**
 * Executes command, tees and captures stdout and stderr. Ignores failed commands.
 *
 * @param cmdLineArgs
 * @return a tuple of captured stdout + captured stderr
 */
Tuple2<String, String> runAndTeeStdOutStdErr(cmdLineArgs) {
  def execOps = project.objects.newInstance(ExecOps).execOps
  println "${projectDir}> `${cmdLineArgs.join ' '}`"
  new ByteArrayOutputStream().withStream { cmdStdOut ->
    new ByteArrayOutputStream().withStream { cmdStdErr ->
      execOps.exec {
        commandLine = cmdLineArgs
        standardOutput = new TeeOutputStream(System.out, cmdStdOut)
        errorOutput = new TeeOutputStream(System.err, cmdStdErr)
        ignoreExitValue = true
      }
      new Tuple2<>(cmdStdOut.toString(), cmdStdErr.toString())
    }
  }
}

tasks.register('execCommands') {
  dependsOn myExec
  def execOps = project.objects.newInstance(ExecOps).execOps
  doLast {
    println "\nexecCommands: Executing a command and suppressing a failure"
    println '====='
    def result = run(['bash', '-c', 'set'], true, [FOO: 'BAR'])
    println "Completed with the exit code: ${result.exitValue}"
    println '====='

    println "\nExecuting a command and capturing stdout and stderr"
    println '====='
    new ByteArrayOutputStream().withStream { cmdStdOut ->
      new ByteArrayOutputStream().withStream { cmdStdErr ->
        execOps.exec {
          commandLine = ['ls', '-l']
          standardOutput = cmdStdOut
          errorOutput = cmdStdErr
        }
        println '===== stdout:'
        print cmdStdOut
        println '===== stderr:'
        print cmdStdErr
        println '====='
      }
    }

    def cmdLineArgs = ['ls', '-l']
    println "\nExecuting a command and teeing stdout and stderr. It should stop on errors."
    println '====='
    println "<main>: ${projectDir}> `${cmdLineArgs.join ' '}`"
    new ByteArrayOutputStream().withStream { cmdStdOut ->
      new ByteArrayOutputStream().withStream { cmdStdErr ->
        execOps.exec {
          commandLine cmdLineArgs
          standardOutput = new TeeOutputStream(System.out, cmdStdOut)
          errorOutput = new TeeOutputStream(System.err, cmdStdErr)
        }
        println '===== Captured stdout:'
        print cmdStdOut
        println '===== Captured stderr:'
        print cmdStdErr
        println '====='
      }
    }

    println "\nExecuting a command with error suppression and teeing stdout and stderr via generic function"
    println '====='
    def cmdOutput = runAndTeeStdOutStdErr(['ls', 'bar'])
    println '===== Captured stdout:'
    print cmdOutput.v1
    println '===== Captured stderr:'
    print cmdOutput.v2
    println '====='

    println "\nExecuting a command and teeing stdout via generic function"
    println '====='
    def cmdStdOut = runAndCaptureStdOut(['ls', '-l'])
    println '===== Captured stdout:'
    print cmdStdOut
    println '====='
  }
}

tasks.register('generateConfig') {
  final def REQUIRED_VARS = ['CUSTOM_PROP']

  def configFileSource = 'config/example.service'
  def props = [CUSTOM_PROP: '']
  def generatedConfigDir = layout.buildDirectory.dir('generated')

  inputs.property 'systemEnv', systemEnv
  inputs.files configFileSource

  outputs.file generatedConfigDir.get().file('example.service')

  doLast {
    println "The output directory=${generatedConfigDir.get()}"

    for (def requiredVar in REQUIRED_VARS) {
      assert systemEnv.containsKey(requiredVar): "`$requiredVar` is not set in the environment"
      props[requiredVar] = systemEnv[requiredVar]
    }

    copy {
      from "${configFileSource}"
      into generatedConfigDir
      expand(props)
      filteringCharset = 'UTF-8'
    }
  }
}

println "ext.foo=${ext.foo}"
println "ext.baz=${ext.baz}"

/**
 * Custom function
 */
void fun() {
  println "fun()>"
  println "foo=${foo}"
  /*
  ERROR: Could not get unknown property 'bar'

  println "bar=${bar}"
  */
  println "baz=${baz}"
}

tasks.register('printVars') {
  group = 'Help'
  description = 'Prints environment, JVM System Properties and other project info.'

  dependsOn nodeSetup

  println 'task :printVars in configuration phase.'
  println "foo=${foo}"
  println "bar=${bar}"
  println "baz=${baz}"

  def props = project.properties
  def extProps = project.extensions.extraProperties.properties

  /*
  Fail: extra properties extension does not exist.

  println "ext.foo=${ext.foo}"
  println "ext.bar=${ext.bar}"
  */

  doLast {
    println "foo=${foo}"
    println "bar=${bar}"
    println "baz=${baz}"

    /*
    Fail: extra properties extension does not exist.

    println "ext.foo=${ext.foo}"
    println "ext.baz=${ext.baz}"
    */

    println "project.ext.foo=${extProps.foo}"
    println "project.ext.baz=${extProps.baz}"

    fun()

    println '\n## Project Extra Properties ##\n'
    extProps.sort().each { key, value -> println "${key}=${value}" }
    println "Is `overwriteReleaseImage` truthy: ${isTruthyProp('overwriteReleaseImage')}"

    println '\n## Project Properties ##\n'
    props.sort().each { key, value -> println "${key}=${value}" }

    println '\n## Gradle variables ##\n'
    def logLevel = gradle.startParameter.logLevel
    println "Current logging level=${logLevel}"
    println "Project build directory=${layout.buildDirectory.get()}"
    println "Binary output directory=${binDir.get()}"

    println '\n## Gradle JVM properties ##\n'
    System.properties.sort().each { key, value -> println "${key}=${value}"
    }

    println '\n## Environment variables ##\n'
    systemEnv.sort().each { key, value -> println "${key}=${value}"
    }

    println '\n## Node.js executable ##\n'
    println detectNodeExecutable()
  }
}

defaultTasks = ['execCommands', 'generateConfig', 'printVars']