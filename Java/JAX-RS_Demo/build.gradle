plugins {
  id 'base'

  //region Server-side stack
  id 'java'

  /*
  Adds Spring Boot tasks and configurations depending on other plug-ins.
  The version of this plug-in determines versions of Spring Boot and its BOM (managed dependencies).

  NOTE: temporarily enable `spring-boot-properties-migrator` dependency below after all Sprint Boot upgrades.
  */
  id 'org.springframework.boot' version '3.0.+'

  // Enables using the `spring-boot-dependencies` BOM and Spring Boot Starters inheriting versions from the BOM
  id 'io.spring.dependency-management' version '1.1.+'

  /*
  Simplifies the use of Lombok and is recommended to use by Lombok.
    * The `javadoc` task is configured to read the delombok-ed sources instead of the actual sources.

  For each source set:
    * Lombok is added to the `annotationProcessor` and `compileOnly` configurations.
    * A `delombok` task is created.
    * `lombok-mapstruct-binding` is added when 'org.mapstruct:mapstruct-processor' is found.
    * The compile tasks will consider the lombok.config(s) in their up-to-date checks.
  */
  // No `.patch` version number components
  // TBD Resolve the deprecation warning
  id 'io.freefair.lombok' version '8.11'
  //endregion

  // Information on task metadata and dependencies
  id 'org.barfuin.gradle.taskinfo' version '2.2.+'
}

repositories {
  // The Maven central repository
  mavenCentral()
}

description = 'JAX-RS Demo'
// Version to build: should use Sem Ver 2.0 convention (https://semver.org/), that is `MAJOR.MINOR.PATCH[-PRE.RELEASE]`
if (!version || version == 'unspecified') {
  // Default the version when not specified or blank in project properties
  version = '1.1.0'
}
// build-info: `build.group`
group = 'org.houseofsoft'

logger.lifecycle "\n${description} v${version}\n"

def systemEnv = System.getenv()
def os = System.getProperty('os.name').toLowerCase()

//region Gradle info
if (logger.isEnabled(LogLevel.LIFECYCLE)) {
  print "Built by Gradle ${gradle.gradleVersion} (${gradle.gradleHomeDir})"
  if (logger.isEnabled(LogLevel.DEBUG) && os in ['linux', 'mac os x']) {
    println " and the user:"
    exec {
      commandLine 'id'
    }
  } else {
    println ''
  }

  // `System.properties['java.vendor.version']` may point to a JVM different from Gradle's
  logger.lifecycle "Gradle JVM: ${System.properties['java.vendor']} ${System.properties['java.vm.version']} " +
      "@ ${System.properties['java.home']}"
}

if (logger.isEnabled(LogLevel.INFO)) {
  def buildCacheDir = systemEnv['GRADLE_USER_HOME'] ?: System.properties['user.home'] + '/.gradle'
  logger.info "Build cache: ${buildCacheDir}"

  def sysPath = systemEnv['PATH'] ?: systemEnv['Path']
  logger.info "PATH=${sysPath}"
}
//endregion

dependencies {
//region Spring Boot-managed dependencies
  /*
  Versions are specified by the Sprint Boot BOM, which is added by `io.spring.dependency-management`.
  See the list of all managed dependencies here:
  https://docs.spring.io/spring-boot/docs/2.7.18/reference/htmlsingle/#appendix.dependency-versions
  */

  annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'

  // Core starter, including auto-configuration support, logging and YAML
  implementation 'org.springframework.boot:spring-boot-starter'

  // Starter for building RESTful web apps using `JAX-RS` and `Jersey`. An alternative to `spring-boot-starter-web`.
  implementation 'org.springframework.boot:spring-boot-starter-jersey'

  /*
  Starter to provide the web app servlet, serving static content using Spring MVC and Tomcat as the default
  embedded container.
  */
  implementation 'org.springframework.boot:spring-boot-starter-web'
  //implementation 'org.springframework.boot:spring-boot-starter-tomcat'

  // Starter for using Spring Security
  //implementation 'org.springframework.boot:spring-boot-starter-security'

  implementation 'org.slf4j:slf4j-api'
  implementation 'org.slf4j:log4j-over-slf4j'
  implementation 'org.apache.commons:commons-lang3'

  /*
  Spring Boot Developer Tools will be automatically disabled when running a JAR or if the app is started from a
  special classloader.

  Note: Dev Tools will:
      1. Disable the Spring caching options by default
      2. Enable DEBUG logging for the web logging group
      3. Automatically restart the app whenever files on the classpath change
      4. Embed `LiveReload` server
  */
  //TBD Resolve the classpath INFO-level warning
  //developmentOnly 'org.springframework.boot:spring-boot-devtools'

  /*
  Prints diagnostics at startup, but also temporarily migrate properties at runtime for you.
  */
  runtimeOnly 'org.springframework.boot:spring-boot-properties-migrator'
  //endregion

  //region Other dependencies: specific (fixed or dynamic) versions. If you omit a version, the latest will be used.

  // Google Guava: a common-purpose library
  // Dynamic version + flavor (e.g. `guava-33.3.1-jre.jar`) can be specified using a version range, but not `.+`.
  implementation 'com.google.guava:guava:[33.3-jre,33.4-jre)'

  // FindBugs: provides null-check annotations
  implementation 'com.google.code.findbugs:jsr305:3.+'

  implementation 'io.jsonwebtoken:jjwt-api:0.12.+'
  runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.+'
  runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.+'

  //endregion
}

final def JAVA_VER = 17

java {
  /*
  Set up all compile, test and javadoc tasks to use the defined Java toolchain which may be different than the one
  Gradle itself uses. Locally installed JVMs are detected and JRE/JDK matching the requirements below is chosen. If no
  match is found, Gradle will automatically download and use the right JDK from a specified vendor.
  */
  toolchain {
    languageVersion = JavaLanguageVersion.of(JAVA_VER)
    vendor = JvmVendorSpec.AMAZON // optional, defaults to `AdoptOpenJDK`
  }

  consistentResolution {
    useCompileClasspathVersions()
  }
}

//region project Java toolchain info
// access the default toolchain
def toolchain = project.getExtensions().getByType(JavaPluginExtension.class).toolchain
// acquire a provider that returns the launcher for the toolchain
def service = project.getExtensions().getByType(JavaToolchainService.class)
def javaLauncher = service.launcherFor(toolchain).get()
def jvm = javaLauncher.metadata
// `jvm.installationPath` is the project's Java Home
logger.lifecycle "\nProject toolchain JVM: ${jvm.vendor} ${jvm.javaRuntimeVersion} @ ${jvm.installationPath}"
//endregion

// Spring Boot Actuatorâ€™s info endpoint automatically publishes information about a build
springBoot {
  buildInfo()
}

// The output directory for project's binary artifacts: `itasng.jar` and `itasng.sh` (formerly `project.libsDirectory`)
def binDir = project.layout.buildDirectory.dir('libs').get()

/*
Build scans should be useful primarily for troubleshooting and build tuning.
Create and publish a scan by running any build with `--scan`, e.g. `gradlew assemble --scan`.
*/
develocity {
  buildScan {
    termsOfUseUrl = 'https://gradle.com/help/legal-terms-of-use'
    termsOfUseAgree = 'yes'
    // publish Build Scans when explicitly requested (`--scan`)
    publishing.onlyIf { false }
    /*
    By default, Build Scans are uploaded in the background after the build has finished. This allows the build to
    finish sooner, but can be problematic in build environments (e.g. ephemeral CI agents) that terminate as soon as
    the build is finished, as the upload may be terminated before it completes.
    */
    uploadInBackground = false
  }
}

tasks.register('printVersion') {
  group 'Help'
  description 'Prints application version.'
  doLast {
    println "APP_VERSION=${version}"
  }
}

tasks.register('printVars') {
  group 'Help'
  description 'Prints environment, Gradle JVM system properties, etc.'
  doLast {
    println '## Environment variables ##\n'
    systemEnv.sort().each { key, value -> println "${key}=${value}"
    }

    println '\n## Gradle JVM properties ##\n'
    System.properties.sort().each { key, value -> println "${key}=${value}"
    }

    println '\n## Gradle variables ##\n'

    def logLevel = gradle.startParameter.logLevel
    println "Current logging level=${logLevel}"

    println "Project build directory=${layout.buildDirectory.get()}"
    println "Binary output directory=${binDir}"
  }
}

